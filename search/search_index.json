{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#logging-in-to-the-uchicago-analysis-facility","title":"Logging in to the UChicago Analysis Facility","text":"<p>First you will need to sign up on the Analysis Facility website. </p> <p>Please use your institutional or CERN identity (lxplus username) when signing up, as this will make the approval process smoother. You should set your institution to be your home institute. If e.g. you are from the University of Chicago but use your CERN credentials, you should set the institution under your profile to be the University of Chicago.</p> <p>As part of signing up you will need to upload an SSH Public Key.</p> <p>If you are not sure if you have generated an SSH Public Key before, try the following command (Mac/Linux) on your laptop to print the content of the file that contains the SSH Public Key:</p> <pre><code>cat ~/.ssh/id_rsa.pub\n</code></pre> <p>If the file exists, you should be able to copy the contents of this file to your profile on the AF website.</p> <pre><code>Important: Do not copy the contents of a file that does not end in .pub. You must only upload the public (.pub) part of the key.\n</code></pre> <p>If you do not have a public key (the file doesn't exist), you can generate one via the following command (Mac/Linux):</p> <pre><code>ssh-keygen -t rsa\n</code></pre> <p>Upload the resulting public key (ending in .pub) to your profile.</p> <p>Once you have uploaded a key, it will take a little bit of time to process your profile and add your account to the system. After 10-15 minutes, you ought to be able to login via SSH:</p> <pre><code>ssh &lt;username&gt;@login.af.uchicago.edu\n</code></pre> <p>If it does not work, please double check that you have been approved, have a public key uploaded and have waited at least 15 minutes. If you still have an issue, feel free to reach out to us for help.</p>"},{"location":"#using-analysis-facility-filesystems","title":"Using Analysis Facility Filesystems","text":"<p>The UChicago analysis facility has three filesystems that you should be aware of when running workloads. The table below describes their differences:</p> Filesystem Quota Path Backup Notes $HOME 100 GB /home/$USER Yes Solid-state filesystem, shared to all worker nodes $DATA 5 TB /data/$USER No CephFS filesystem, shared to all worker nodes $SCRATCH n/a /scratch No Ephemeral storage for workloads, local to worker nodes"},{"location":"coffeacasa/","title":"Coffea Casa","text":""},{"location":"coffeacasa/#prerequisites","title":"Prerequisites","text":"<p>The primary mode of analysis with coffea-casa is coffea. Coffea provides plenty of examples to users in its documentation A good starting point may be this tutorial on columnar analysis in coffea.</p> <p>Knowledge of Python is also assumed. Standard coffea analyses are contained within Jupyter Notebooks, which allow for dynamic, block-by-block execution of code. Coffea-casa employs the JupyterLab interface. JupyterLab is designed for hosting Jupyter Notebooks on the web, and permits the usage of additional features within its environment, including Git access, compatibility with cluster computing tools, and much, much more.</p> <p>If you aren't familiar with any of these tools, please click on the links above for additional resources, and get acquainted with how they work. If you want examples of how coffea-casa merges these tools, refer to the gallery of coffea-casa examples.</p>"},{"location":"coffeacasa/#access","title":"Access","text":"<p>Please use https://coffea.af.uchicago.edu as an access point to the Coffea-Casa Analysis Facility @ UChicago.</p> <p></p>"},{"location":"coffeacasa/#atlas-authz-authentication-instance","title":"ATLAS AuthZ Authentication Instance","text":"<p>Currently Coffea-Casa Analysis Facility @ UChicago can support any member of ATLAS.</p> <p>Sign in with your ATLAS CERN credential:</p> <p></p> <p></p>"},{"location":"coffeacasa/#docker-image-selection","title":"Docker Image Selection","text":"<p>For high efficient analysis using coffea package, powered with Dask and HTCondor please select:</p> <p></p> <p>After you will be forwarded to your personal Jupyterhub instance running at Analysis Facility @ UChicago:</p> <p></p>"},{"location":"coffeacasa/#cluster-resources-in-coffea-casa-analysis-facility-uchicago","title":"Cluster Resources in Coffea-Casa Analysis Facility @ UChicago","text":"<p>By default, the Coffea-casa Dask cluster should provide you with a scheduler and workers, which you can see by clicking on the colored Dask icon in the left sidebar.</p> <p></p> <p>As soon as you will start your computations, you will notice that available resources at the Coffea-Casa Analysis Facility @ UChicago can easily autoscale depending on available resources in the HTCondor pool at AF UChicago.</p> <p></p>"},{"location":"coffeacasa/#opening-a-new-console-or-file","title":"Opening a New Console or File","text":"<p>There are three ways by which you can open a new tab within coffea-casa. Two are located within the File menu at the very top of the JupyterLab interface: New and New Launcher.</p> <p></p> <p>The New dropdown menu allows you to open the console or a file of a specified format directly. The New Launcher option creates a new tab with buttons that permit you to launch a console or a new file, exactly like the interface you are shown when you first open coffea-casa.</p> <p>The final way is specific to the File Browser tab of the sidebar.</p> <p></p> <p>This behaves exactly like the New Launcher option above.</p> <pre><code>Regardless of the method you use to open a new file, the file will be saved to the current directory of your **File Browser.**\n</code></pre>"},{"location":"coffeacasa/#using-git","title":"Using Git","text":"<p>Cloning a repository in the Coffea-casa Analysis Facility @ UChicago is simple, though it can be a little confusing because it is spread across two tabs in the sidebar: the File Browser and the Git tabs.</p> <p>In order to clone a repository, first go to the Git tab. It should look like this:</p> <p></p> <p>Simply click the appropriate button (initialize a repository, or clone a repository) and you'll be hooked up to GitHub. This should then take you to the File Browser tab, which is where you can see all of the repositories you have cloned in your JupyterLab instance. The File Browser should look like this:</p> <p></p> <p>If you wish to change repositories, simply click the folder button to enter the root directory. If you are in the root directory, the Git tab will reset and allow you to clone another repository.</p> <p>If you wish to commit, push, or pull from the repository you currently have active in the File Browser, then you can return to the Git tab. It should change to look like this, so long as you have a repository open in the File Browser:</p> <p></p> <p>The buttons in the top right allow for pulling and pushing respectively. When you have edited files in a directory, they will show up under the Changed category, at which point you can hit the + to add them to a commit (at which point they will show up under Staged). Filling out the box at the bottom of the sidebar will file your commit, and prepare it for you to push.</p>"},{"location":"job_submission/","title":"Submitting to the Analysis Facility","text":"<p>The UChicago Analysis Facility uses HTCondor for batch workloads. You will need to define an executable script and a \"submit\" file that describes your job. A simple job that loads the ATLAS environment looks something like this:</p> <p>Job script, called myjob.sh:</p> <pre><code>#!/bin/bash\nexport ATLAS_LOCAL_ROOT_BASE=/cvmfs/atlas.cern.ch/repo/ATLASLocalRootBase\nexport ALRB_localConfigDir=$HOME/localConfig\nsource ${ATLAS_LOCAL_ROOT_BASE}/user/atlasLocalSetup.sh\n# at this point, you can lsetup root, rucio, athena, etc..\n</code></pre> <p>Submit file, called myjob.sub:</p> <pre><code>Universe = vanilla\n\nOutput = myjob.$(Cluster).$(Process).out\nError = myjob.$(Cluster).$(Process).err\nLog = myjob.log\n\nExecutable = myjob.sh\n\nrequest_memory = 1GB\nrequest_cpus = 1\n\nQueue 1\n</code></pre> <p>By default, your jobs will be submitted via the long queue, with no time limits. However, in order to make your jobs start faster, you can request specifically to send them via the short queue. This is for jobs that should take under 4 hours. For this purpose, you need to add a line in your submit file:</p> <pre><code>+queue=\"short\"\n</code></pre> <p>The condor_submit command is used to queue jobs:</p> <pre><code>$ condor_submit myjob.sub\nSubmitting job(s).\n1 job(s) submitted to cluster 17.\n</code></pre> <p>And the condor_q command is used to view the queue:</p> <pre><code>[lincolnb@login01 ~]$ condor_q\n-- Schedd: head01.af.uchicago.edu : &amp;lt;192.170.240.14:9618?... @ 07/22/21 11:28:26\nOWNER    BATCH_NAME    SUBMITTED   DONE   RUN    IDLE  TOTAL JOB_IDS\nlincolnb ID: 17       7/22 11:27      _      1      _      1 17.0\n\nTotal for query: 1 jobs; 0 completed, 0 removed, 0 idle, 1 running, 0 held, 0 suspended\nTotal for lincolnb: 1 jobs; 0 completed, 0 removed, 0 idle, 1 running, 0 held, 0 suspended\nTotal for all users: 1 jobs; 0 completed, 0 removed, 0 idle, 1 running, 0 held, 0 suspended\n</code></pre>"},{"location":"job_submission/#configuring-your-jobs-to-use-an-x509-proxy-certificate","title":"Configuring your jobs to use an X509 Proxy Certificate","text":"<p>If you need to use an X509 Proxy, e.g. to access ATLAS Data, you will want to copy your X509 certificate to the Analysis Facility.</p> <p>Store your certificate in <code>$HOME/.globus</code> and create a ATLAS VOMS proxy in the usual way:</p> <pre><code>export ATLAS_LOCAL_ROOT_BASE=/cvmfs/atlas.cern.ch/repo/ATLASLocalRootBase\nexport ALRB_localConfigDir=$HOME/localConfig\nsource ${ATLAS_LOCAL_ROOT_BASE}/user/atlasLocalSetup.sh\nlsetup emi\nvoms-proxy-init -voms atlas -out $HOME/x509proxy\n</code></pre> <p>You will want to generate the proxy on, or copy it to, the shared $HOME filesystem so that the HTCondor scheduler can find and read the proxy. With the following additions to your jobscript, HTCondor will configure the job enviroment automatically for X509 authenticated data access:</p> <pre><code>use_x509userproxy = true\nx509userproxy = /home/YOURUSERNAME/x509proxy\n</code></pre> <p>E.g., in the job above for the user lincolnb:</p> <pre><code>Universe = vanilla\n\nOutput = myjob.$(Cluster).$(Process).out\nError = myjob.$(Cluster).$(Process).err\nLog = myjob.log\n\nExecutable = myjob.sh\n\nuse_x509userproxy = true\nx509userproxy = /home/lincolnb/x509proxy\n\nrequest_memory = 1GB\nrequest_cpus = 1\n\nQueue 1\n</code></pre>"},{"location":"job_submission/#limits","title":"Limits","text":"<p>Currently there is a limit to max of 64GB RAM and max 16 cores/CPUs that you can request per job.</p>"},{"location":"job_submission/#using-analysis-facility-filesystems","title":"Using Analysis Facility Filesystems","text":"<p>When submitting jobs, you should try to use the local scratch filesystem whenever possible. This will help you be a \"good neighbor\" to other users on the system, and reduce overall stress on the shared filesystems, which can lead to slowness, downtimes, etc. By default, jobs start in the $SCRATCH directory on the worker nodes. Output data will need to be staged to the shared filesystem or it will be lost!</p> <p>In the following example, data is read from Rucio, we pretend to process it, and then push a small output copied back to the $HOME filesystem. It assumes your X509 proxy certificate is valid and in your home directory.</p> <pre><code>#!/bin/bash\nexport ATLAS_LOCAL_ROOT_BASE=/cvmfs/atlas.cern.ch/repo/ATLASLocalRootBase\nexport ALRB_localConfigDir=$HOME/localConfig\nsource ${ATLAS_LOCAL_ROOT_BASE}/user/atlasLocalSetup.sh\nlsetup rucio\nrucio --verbose download --rse MWT2_DATADISK data16_13TeV:AOD.11071822._001488.pool.root.1\n\n# You can run things like asetup as well\nasetup AnalysisBase,21.2.81\n\n# This is where you would do your data analysis via AnalysisBase, etc. We will\n# just pretend to do that, and truncate the file to simulate generating an\n# output file. This is definitely not what you want to do in a real analysis!\ncd data16_13TeV\ntruncate --size 10MB AOD.11071822._001488.pool.root.1\ncp AOD.11071822._001488.pool.root.1 $HOME/myjob.output\n</code></pre> <p>It gets submitted in the usual way:</p> <pre><code>Universe = vanilla\n\nOutput = myjob.$(Cluster).$(Process).out\nError = myjob.$(Cluster).$(Process).err\nLog = myjob.log\n\nExecutable = myjob.sh\n\nuse_x509userproxy = true\nx509userproxy = /home/lincolnb/x509proxy\n\nrequest_memory = 1GB\nrequest_cpus = 1\n\nQueue 1\n</code></pre> <p>And then:</p> <pre><code>$ condor_submit myjob.sub\nSubmitting job(s).\n1 job(s) submitted to cluster 17.\n</code></pre>"},{"location":"job_submission/#using-docker-singularity-containers-advanced","title":"Using Docker / Singularity containers (Advanced)","text":"<p>Some users may want to bring their own container-based workloads to the Analysis Facility. We support both Docker-based jobs as well as Singularity-based jobs. Additionally, the CVMFS repository unpacked.cern.ch is mounted on all nodes.</p> <p>If, for whatever reason, you wanted to run a Debian Linux-based container on the Analysis Facilty, it would be as simple as the following Job file:</p> <pre><code>universe                = docker\ndocker_image            = debian\nexecutable              = /bin/cat\narguments               = /etc/hosts\nshould_transfer_files   = YES\nwhen_to_transfer_output = ON_EXIT\noutput                  = out.$(Process)\nerror                   = err.$(Process)\nlog                     = log.$(Process)\nrequest_memory          = 1000M\nqueue 1\n</code></pre> <p>Similarly, if you would like to run a Singularity container, such as the ones provided in th unpacked.cern.ch CVMFS repo, you can submit a normal vanilla universe job, with a job executable that looks something like the following:</p> <pre><code>#!/bin/bash\nsingularity run -B /cvmfs -B /home /cvmfs/unpacked.cern.ch/registry.hub.docker.com/atlas/rucio-clients:default rucio --version\n</code></pre> <p>Replacing the <code>rucio-clients:default</code> container and <code>rucio --version</code> executable with your preferred software.</p>"},{"location":"local-ddm/","title":"Local DDM","text":""},{"location":"local-ddm/#accessing-data-directly-from-ddms","title":"Accessing data directly from DDMs","text":"<p>If your dataset is available at the local DDM endpoint (eg. MWT2_UC_LOCALGROUPDISK), it would be very performat to read the data directly from it. First you need to discover paths to the files of your dataset. This is easiest done in Rucio. You would issue a command like:</p> <pre><code>setupATLAS\nlsetup rucio\nrucio\n# get your grid proxy\nvoms-proxy-init -voms atlas\nrucio list-file-replicas user.ivukotic:xcache.test.dat --protocols root --pfns\n</code></pre> <p>This will give you a list of paths to all of the files and all the replicas in your dataset. You can also limit it to only paths to specific RSES:</p> <pre><code>rucio list-file-replicas user.ivukotic:xcache.test.dat --protocols root --pfns --rses MWT2_UC_LOCALGROUPDISK\n# output will look like this:\n# root://fax.mwt2.org:1094//pnfs/uchicago.edu/atlaslocalgroupdisk/rucio/user/ivukotic/7d/9b/xcache.test.dat\n</code></pre> <p>If you need only some files, you can simply grep or awk for them and save filepaths to txt file that your jobs will use.</p>"},{"location":"ml_platform/","title":"JupyterLab","text":"<p>To support machine learning code development, our users can deploy one or more private JupyterLab applications.</p> <p>To encourage fair sharing these applications are time limited. We also ask users to request only the resources that they need.</p>"},{"location":"ml_platform/#selecting-gpu-memory-and-instances","title":"Selecting GPU memory and instances","text":"<p>The AF cluster has four NVIDIA A100 GPUs. Each GPU can be partitioned into seven GPU instances. This means the AF cluster can have up to 28 GPU instances running in parallel. </p> <p>A user can request 0 to 7 GPU instances as a resource for the notebook. A user can request 40,836 MB of memory for an entire A100 GPU, or 4864 MB of memory for a MIG instance.</p>"},{"location":"ml_platform/#selecting-a-docker-image","title":"Selecting a Docker image","text":"<p>Users can choose from five images:</p> <ul> <li><code>ml_platform:latest</code> -  has most of the ML packages (Tensorflow, Keras, ScikitLearn,...) preinstalled, and a small tutorial with example codes in /ML_platform_tests/tutorial, it supports NVidia GPUs and has ROOT preinstalled.</li> <li><code>ml_platform:conda</code> - comes with full anaconda.</li> <li><code>ml_platform:julia</code> - with Julia programming languge</li> <li><code>ml_platform:lava</code> - with Intel Lava neuromorphic computing framework</li> <li><code>ml_platform:centos</code></li> <li><code>AB-stable</code> - based on AnalysisBase</li> <li><code>AB-dev</code> - based on AnalysisBase but with cutting edge uproot, dask, awkward arrays, etc.</li> </ul> <p>Users can choose between two images: One with full anaconda (ivukotic/ml_platform:conda) and one with NVidia GPU and ROOT support (ivukotic/ml_platform:latest). The later has most of the ML packages (Tensorflow, Keras, ScikitLearn,...) preinstalled, and a small tutorial with example codes in /ML_platform_tests/tutorial. For software additions and upgrades please contact ivukotic@uchicago.edu.</p>"},{"location":"ml_platform/#tutorials","title":"Tutorials","text":"<p>Basic usage of the platform can be exerienced by running the set of tutorials that come preinstalled with both latest and conda image.</p>"},{"location":"ml_platform/#running-in-conda","title":"Running in conda","text":"<p>To run tutorial in conda environment, one first has to initialize conda. Simply open a jupyter lab terminal, and execute: conda init. Close that terminal and open a new one. This will drop you in (base) conda environment. You may now switch to a HEP relevant environment by executing: conda activate codas-hep.</p>"},{"location":"servicex/","title":"ServiceX","text":"<p>When dealing with very large datasets it is often better to do initial data filtering, augmentation using <code>ServiceX &lt;https://iris-hep.org/projects/servicex&gt;</code>_. ServiceX transformation produces output as an Awkward Array. The array can then be used in a regular Coffea processing. Here a scheme explaining the workflow:</p> <p></p> <p>There are two different, UC AF deployed ServiceX instances. The only difference between them is the type of input data they are capable of processing. Uproot processes any kind of \"flat\" ROOT files, while xAOD processes only Rucio registered xAOD files.</p> <p>To use them one has to register and get approved.  Sign in will lead you to a Globus registration page, where you may choose to use account connected to your institution:</p> <p></p> <p>Once approved, you will be able to see status of your requests in the dashboard:</p> <p></p> <p>For your code to be able to authenticate your requests, you need to download a servicex.yaml file, that should be placed in your working directory. The file is downloaded from your profile page:</p> <p></p> <p>For an example analysis using ServiceX and Coffea look here.</p>"},{"location":"servicex/#more-examples","title":"More Examples","text":"<p>Columnar data analysis with DAOD_PHYSLITE here.</p> <p>ServiceX analysis on ROOT files, with Coffea, and TRExFitter here.</p>"},{"location":"xcache/","title":"XCache","text":"<p>To speed up remote data access, Analysis Facility maintains an XCache server (managed through SLATE), with 25 x 1.5 TB NVMes and 2x25 Gbps NIC.</p> <p>Users that want do access remote data of their own (on EOS or elsewhere) can manually add the prefix <code>root://xcache.af.uchicago.edu:1094//</code> to their root paths, eg:</p> <p>If the original path is eg.:</p> <pre><code>root://someserver.org:1094//atlaslocalgroupdisk/rucio/user/mgeyik/63/c4/user.mgeyik.26617246._000006.out.root\n</code></pre> <p>make it:</p> <pre><code>root://xcache.af.uchicago.edu:1094//root://someserver.org:1094//atlaslocalgroupdisk/rucio/user/mgeyik/63/c4/user.mgeyik.26617246._000006.out.root\n</code></pre> <p>While initial data access will be slightly slower, following accesses will be lightning fast.</p> <p>NB. ServiceX uses the XCache by default.</p>"}]}